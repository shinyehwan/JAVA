package chapter9;

class Main {
    public static void main(String[] args) {
        // 오직 main 함수 안에서만 활동하는 지역변수를 만들겠습니다.
        // main 함수에서는 더 이상 a라는 이름의 다른 변수를 만들 수가 없다.
        // main 함수가 시작되면 a변수는 만들어진다.
        // main 함수가 끝나면 a변수는 사라진다.
        // a에는 단 한순간 이라도 정수 이외의 값을 가질 수 없다.
        // 그래서 현재 a에는 0(쓰레기 값)이 들어가 있다.
        // a에는 오직 -21억 이상, 21억 이하의 정수만 들어갈 수 있다.
        // a에 정수가 아닌 값을 넣으려고 시도하면 자동으로 정수화 되어서 들어간다.
        // 만약에 위 정수화가 위험할 수 있는 가능성이 조금이라도 있다면 오류가 발생한다.
        int a;
    }
}

class Main {
    public static void main(String[] args) {
        // 무기 리모콘을 만들 수 있다.
        // 무기 객체를 만들 수 있다.
        // 무기 리모콘만 들어가는 변수를 만들 수 있다.
        // 무기 리모콘은 버튼의 개수가 1개이다.
        // 무기 객체는 기능의 개수가 1개이다.
        // class 무기 { void 공격() { } } 의 의미

    }
}

class 무기 {
    void 공격() { }
}

class 칼 extends 무기 {
    void 사과를_깍다() { }
}

class Main {
    public static void main(String[] args) {
        게임.작동하다();
    }
}

class 게임 {
    static void 작동하다() {
        // 오직 무기 리모콘만 저장 할 수 있는 변수가 만들어진다.
        // 그 변수의 이름은 `a무기`이다.
        // 해당 변수에는 단 한순간이라도 무기 리모콘 아닌 값이 들어갈 수 없다.
        // 그래서 현재 위 a무기 변수에는 쓰레기 리모콘이 들어있다.
        // 그 쓰레기 리모콘의 버튼 개수는 1개이다.
        // 물론 그 버튼을 누르면 오류가 난다.
        // 왜냐하면 그 쓰레기 리모콘은 객체와 연결되어 있지 않기 때문이다.
        // a무기에는 무기리모콘은 당연히 저장 될 수 있다.
        // a무기에 무기리모콘이 아닌 다른 리모콘이 저장 되려 할 때 해당 리모콘은 자동으로 무기리모콘으로 변해서 저장된다.
        // 다른 리모콘이 만약에 무기 리모콘으로 바뀌는게 안전하지 않을 수 있으면 오류가 발생한다.
        // a무기 라는 변수(공간)은 `작동하다` 함수가 시작할 때 만들어 진다.
        // a무기 라는 변수(공간)은 `작동하다` 함수가 끝날 때 사라진다.
        // 여기서 당연하게도 a무기 에 들어있던 리모콘은 변수가 사라질 때 같이 사라진다.
        무기 a무기;

        // 무기 객체는 객체들만 사는 나라(힙)에 저장되어 있고 그것의 수명은 `작동하다` 함수가 끝나는 것과 전혀 상관없이 계속 살아간다.
        // 단 객체는 외부에 자신을 가리키는 리모콘의 개수가 0이 되면 힙 내부에 돌아다니고 있는 가비지 컬렉터에 의해서 언젠가 제거된다.
        a무기 = new 무기();
    }
}

class 무기 {
    void 공격() { }
}


class Main {
    public static void main(String[] args) {
        // `class 칼 extends 무기 { }` 의 의미 설명
        // 무기 리모콘의 버튼은 1개이다.
        // 칼 리모콘의 버튼은 2개이다.
        // 무기 클래스에 메서드 3개를 더 넣으면 무기 리모콘의 버튼은 4개가 되고 칼 리모콘의 버튼은 5개가 된다.
        // 칼 리모콘의 버튼 개수는 절대 무기 리모콘의 버튼 개수 보다 적을 수 없다.
        // 다시 말하면 칼 리모콘을 무기 리모콘 으로 바꿀 때 해야할 일은 오직 버튼을 제거하는 일 밖에 없다.
        // 하나의 리모콘을 다른 하나의 리모콘으로 바꾼다는 것은 결국 특정 버튼들을 제거하고, 특정 버튼들을 추가하는 일이다.
        // 버튼을 제거하는 일은 좀 더 불편해지는 일이지만 문제가 되진 않는다. 즉 안전한다.
        // 버튼을 추가하는 일은 좀 더 편리해지는 일이지만 문제가 될 가능성이 다분히 높다. 즉 안전하지 않다.
        // 자바에서는 안전한 일은 자동으로 해주고, 안전하지 않은 일은 개발자의 동의를 받는다.
    }
}

class 무기 {
    void 공격() { }
}

class 칼 extends 무기 {
    void 사과껍질제거() { }
}


// 문제 : `무기 a무기 = new 칼();` 가 실행되는 세부과정을 자세히 쓰세요.

class Main {
    public static void main(String[] args) {
        // 설명 v1
        // 01. 오직 객체만 살 수 있는 메모리 구역(힙)에 `칼` 클래스를 사용해서 객체를 하나 생성합니다.
        // 02. 막 태어난 칼 객체는 내부에 자기자신을 조종할 수 있는 리모콘(this)를 가지고 태어납니다.
        // 03. 이 상태는 현재 오직 칼 객체만 자신을 조종 할 수 있는 상태입니다.
        // 04. 칼 객체는 this 리모콘을 복사하여 돌려줍니다.(일종의 리턴)
        // 05. 무기 클래스로 변수 `a무기` 를 만든다.
        // ps. a무기 변수에는 오직 무기를 조종 할 수 있는 리모콘만 들어갈 수 있다.
        // ps. a무기는 태어나자마자 쓰레기 리모콘을 가지고 있다.
        // ps. 쓰레기 리모콘은 객체와 연결되어 있지 않은 리모콘을 말한다.
        // 06. 칼 객체 리모콘이 오직 무기 리모콘만 들어갈 수 있는 `a무기`에 들어가려 시도 한다.
        // 07. a무기 변수는 칼 객체 리모콘에게 묻는다. "당신은 무기 리모콘 입니까?"
        // 08. 칼 리모콘은 자신이 가리키고 있는 대상이 무기인지 자문해본다. 그리고는 `아니!` 라고 응답한다.
        // 09. a무기 리모콘은 다시 묻는다. "니가 비록 무기리모콘은 아니지만 혹시 무기리모콘으로 변신할 의향이 있니?"
        // 10. 칼 리모콘이 대답을 합니다. "그건 불가능 합니다. 왜냐하면 칼과 무기는 호환되지 않거든.."
        // 11. 호환되지 않는 타입에러 가 발생한다.
        // 에러 이유 : `칼은 무기이다.`는 틀린 명제이기 때문에...

        // 설명 v2(호환되는 경우, 칼 클래스가 무기 클래스를 상속 받았을 경의 설명)
        // 01. 칼 클래스로 힙이라는 영역에 객체가 생성된다. => 칼 객체 생성
        // 02. 칼 객체를 조종할 수 있는 리모콘이 칼 객체 내부에 생성된다. => 칼 리모콘 생성
        // 03. `new 칼();` 가 실행되면 그것은 사라지고 우리에게 칼 리모콘을 돌려준다. => `new 칼();` 코드가 `칼 리모콘`으로 변신한다. 즉 그 자리에 `칼 리모콘만 남는다.`
        // 04. 오직 무기리모콘만 저장 할 수 있는 변수 `a무기`가 만들어진다.
        // 05. 오직 무기리모콘만 저장 할 수 있는 `a무기`는 칼 리모콘을 넣을 수 있는지 체크한다. => 불가능
        // 06. 칼 리모콘이 무기 리모콘으로 바뀔 수 있는지 또는 바뀌어도 문제가 없는지 체크한다. => 가능, 이유 : 무기 클래스에 있는 모든 버튼에 대응하는 기능이 칼 객체에 절대적으로 없을 수 가 없다.
        // 07. 칼 리모콘이 무기 리모콘으로 변신해서 `a무기`로 들어간다.
        무기 a무기 = new 칼();
    }
}

class 무기 {

}

class 칼 {

}

// 문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.

class Main {
    public static void main(String[] args) {
        전사 a전사 = new 전사();

        a전사.공격("브라이언", "칼");
        // 브라이언이(가) 칼(으)로 공격합니다.

        a전사.재공격();
        // 브라이언이(가) 칼(으)로 공격합니다.

        a전사.공격("필립", "창");
        // 필립이(가) 창(으)로 공격합니다.

        a전사.공격("마크", "지팡이");
        // 마크(가) 지팡이(으)로 공격합니다.

        a전사.재공격();
        // 마크(가) 지팡이(으)로 공격합니다.

        a전사.재공격();
        // 마크(가) 지팡이(으)로 공격합니다.
    }
}

class 전사 {
    String 공격자명;
    String 무기명;

    void 공격(String 공격자명, String 무기명) {
        this.공격자명 = 공격자명;
        this.무기명 = 무기명;

        재공격();
    }

    void 재공격() {
        System.out.printf("%s(이)가 %s(으)로 공격합니다!\n", 공격자명, 무기명);
    }
}




// 문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.

class Main {
    public static void main(String[] args) {
        전사 a전사 = new 전사();

        System.out.println("== 정답 ==");

        a전사.공격("브라이언", "칼");
        // 브라이언이(가) 칼(으)로 공격합니다.

        a전사.공격("필립", "창");
        // 필립이(가) 창(으)로 공격합니다.

        a전사.공격("마크", "지팡이");
        // 마크(가) 지팡이(으)로 공격합니다.

        System.out.println("== 정답응용 ==");

        a전사.공격2("브라이언", "칼", 100);
        // 브라이언이(가) 칼(으)로 공격합니다.(공격력 : 100)

        a전사.공격2("필립", "창", 150);
        // 필립이(가) 창(으)로 공격합니다.(공격력 : 150)

        a전사.공격2("마크", "지팡이", 5);
        // 마크(가) 지팡이(으)로 공격합니다.(공격력 : 5)
    }
}

class 전사 {
    void 공격(String 공격자, String 무기) {
        System.out.println(공격자 + "이(가) " + 무기 + "(으)로 공격합니다.");
    }

    void 공격2(String 공격자, String 무기, int 공격력) {
        System.out.println(공격자 + "이(가) " + 무기 + "(으)로 공격합니다.(공격력 : " + 공격력 + ")");
    }
}



